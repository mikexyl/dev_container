{
  // Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  // "Print to console": {
  // 	"scope": "javascript,typescript",
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "Header Guard": {
    "prefix": "hguard",
    "body": ["#ifndef $1_$2_H_", "#define $1_$2_H_\n", "#endif  // $1_$2_H_\n"],
    "description": "Add header definition"
  },
  "TODO": {
    "prefix": "todo",
    "body": ["// TODO(mikexyl): $1 "],
    "description": "Add mikexyl TODO"
  },
  "Shared Ptr": {
    "prefix": "sptr",
    "body": "typedef std::shared_ptr<$1> Ptr;\n"
  },
  "Generate getter": {
    "prefix": "get",
    "body": ["inline const $1& get$2() const {", "\t${3:/* code */", "}"]
  },
  "NotImplemented Fatal": {
    "prefix": "notimpl",
    "body": "LOG(FATAL)<<\"NotImplemented\";"
  },
  "Add Lock Guard": {
    "prefix": "lock",
    "body": ["{", "\tstd::lock_guard<std::mutex> $1_lock($1_mutex_);", "}"]
  },
  "Search in STL Container pointer": {
    "prefix": "findifp",
    "body": [
      "$1::iterator ${2:it} = $3->find($4);",
      "if( ${2:it} != $3->end()) {",
      "  ${5:/* code */}",
      "} else {",
      "  ${6:/* code */}",
      "}"
    ]
  },
  "Search in STL Container": {
    "prefix": "findifp",
    "body": [
      "$1::iterator ${2:it} = $3.find($4);",
      "if( ${2:it} != $3.end()) {",
      "  ${5:/* code */}",
      "} else {",
      "  ${6:/* code */}",
      "}"
    ]
  },
  "Include Header Internal": {
    "prefix": "include",
    "body": "#include \"$1\""
  },
  "Include Header External": {
    "prefix": "include",
    "body": "#include <$1>"
  },
  "For Range": {
    "prefix": "forr",
    "body": ["for(const $1& $2 : $3){", "}"]
  },
  "Add ROS Node": {
    "prefix": "rosnode",
    "body": ["ros::NodeHandle nh_;", "ros::NodeHandle nh_private_;"]
  },
  "Config Struct with OStream Printing": {
    "prefix": "config",
    "body": [
      "  struct Config {",
      "  Config() {}",
      "    friend inline std::ostream& operator<<(std::ostream& s, const Config& v) {",
      "  s << std::endl",
      "    << \"$1 using Config:\"<<std::endl",
      "    << std::endl",
      "    << \"-------------------------------------------\" << std::endl;",
      "  return (s);",
      "}",
      "};\n",
      "static Config getConfigFromRosParam(const ros::NodeHandle& nh_private);"
    ]
  },
  "Ros Param": {
    "prefix": "rosparam",
    "body": "${1:nh_private}.param<$2>(\"$3\", config.$3, config.$3);"
  },
  "Class": {
    "prefix": "class",
    "body": ["class $1{", "public:", "$1(){}", "~$1()=default;", "};"]
  },
  "Print Bool": {
    "prefix": "printbool",
    "body": "static_cast<std::string>($1?\"${2:enabled}\":\"${3:disabled}\")"
  },
  "Code Block": {
    "prefix": "codeblock",
    "body": [
      "// ${1:brief}",
      "CHECK($2)"
    ]
  }
}
